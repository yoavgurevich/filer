{"name":"IDBFS","tagline":"IndexedDB file system","body":"IDBFS is provides a POSIX-like file system interface for browser-based JavaScript.\r\n\r\n* [idbfs.js](https://raw.github.com/js-platform/idbfs/develop/dist/idbfs.js)\r\n* [idbfs.min.js](https://raw.github.com/js-platform/idbfs/develop/dist/idbfs.min.js)\r\n\r\n### Getting Started\r\n\r\nIDBFS is partly based on the `fs` module from node.js. The API is asynchronous and most methods require the caller to provide a callback function. Errors are passed to callbacks through the first parameter.\r\n\r\nTo create a new file system or open an existing one, create a new `FileSystem` instance and pass the name of the file system. A new IndexedDB database is created for each file system.\r\n\r\n#### Example\r\n\r\n````\r\n<script>\r\n  var fs = new IDBFS.FileSystem('local');\r\n  fs.open('/myfile', 'w+', function(err, fd) {\r\n    if (err) throw err;\r\n    fs.close(fd, function(err) {\r\n      if (err) throw err;\r\n      fs.stat('/myfile', function(err, stats) {\r\n        if (err) throw err;\r\n        console.log('stats: ' + JSON.stringify(stats));\r\n      });\r\n    });\r\n  });\r\n</script>\r\n````\r\n\r\nAs with node.js, there is no guarantee that file system operations will be executed in the order they are invoked. Ensure proper ordering by chaining operations in callbacks.\r\n\r\n### Tests\r\n\r\nYou can run the tests from the project by opening the `tests` directory in your browser. You can also run them [here](http://js-platform.github.io/idbfs/tests/).\r\n\r\n### API Reference\r\n\r\nCallbacks for methods that accept them are non-optional. The first callback parameter is reserved for passing errors. It will be `undefined` if no errors occurred and should always be checked.\r\n\r\n#### IDBFS.FileSystem(name, flags)\r\n\r\nFile system constructor, invoked to open an existing file system or create a new one. Accepts a name and optional flags. Use `'FORMAT'` to force IDBFS for format the file system.\r\n\r\n#### fs.stat(path, callback)\r\n\r\nAsynchronous stat(2). Callback gets `(error, stats)`, where `stats` is an object like\r\n\r\n        {\r\n          node: <string> // internal node id (unique)\r\n          dev: <string> // file system name\r\n          size: <number> // file size in bytes\r\n          nlinks: <number> // number of links\r\n          atime: <number> // last access time\r\n          mtime: <number> // last modified time\r\n          ctime: <number> // creation time\r\n          type: <string> // file type (FILE, DIRECTORY, ...)\r\n        }\r\n\r\n#### fs.fstat(fd, callback)\r\n\r\nAsynchronous stat(2). Callback gets `(error, stats)`. See `fs.stat`.\r\n\r\n#### fs.link(oldpath, newpath, callback)\r\n\r\nAsynchronous link(2). Callback gets no additional agruments.\r\n\r\n#### fs.unlink(path, callback)\r\n\r\nAsynchronous unlink(2). Callback gets no additional agruments.\r\n\r\n#### fs.rmdir(path, callback)\r\n\r\nAsynchronous rmdir(2). Callback gets no additional agruments.\r\n\r\n#### fs.mkdir(path, callback)\r\n\r\nAsynchronous mkdir(2). Callback gets no additional agruments.\r\n\r\n#### fs.close(fd, callback)\r\n\r\nAsynchronous close(2). Callback gets no additional agruments.\r\n\r\n#### fs.open(path, flags, callback)\r\n\r\nAsynchronous open(2). Flags can be\r\n\r\n  * `'r'`: Open file for reading. An exception occurs if the file does not exist.\r\n  * `'r+'`: Open file for reading and writing. An exception occurs if the file does not exist.\r\n  * `'w'`: Open file for writing. The file is created (if it does not exist) or truncated (if it exists).\r\n  * `'w+'`: Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).\r\n  * `'a'`: Open file for appending. The file is created if it does not exist.\r\n  * `'a+'`: Open file for reading and appending. The file is created if it does not exist.\r\n\r\nCallback gets `(error, fd)`, where `fd` is the file descriptor.\r\n\r\nUnlike node.js, IDBFS does not accept the optional `mode` parameter since it doesn't yet implement file permissions.\r\n\r\n#### fs.write(fd, buffer, offset, length, position, callback)\r\n\r\nWrite bytes from `buffer` to the file specified by `fd`, where `offset` and `length` describe the part of the buffer to be written. The `position` refers to the offset from the beginning of the file where this data should be written. If `position` is `null`, the data will be written at the current position. See pwrite(2).\r\n\r\nThe callback gets `(error, nbytes)`, where `nbytes` is the number of bytes written.\r\n\r\n#### fs.read(fd, buffer, offset, length, position, callback)\r\n\r\nRead bytes from the file specified by `fd` into `buffer`, where `offset` and `length` describe the part of the buffer to be used. The `position` refers to the offset from the beginning of the file where this data should be read. If `position` is `null`, the data will be written at the current position. See pread(2).\r\n\r\nThe callback gets `(error, nbytes)`, where `nbytes` is the number of bytes read.\r\n\r\n#### fs.lseek(fd, offset, whence, callback)\r\n\r\nAsynchronous lseek(2), where `whence` can be `SET`, `CUR`, or `END`. Callback gets `(error, pos)`, where `pos` is the resulting offset, in bytes, from the beginning of the file.\r\n\r\n#### fs.readdir(path, callback)\r\n\r\nAsynchronous readdir(3). Reads the contents of a directory. Callback gets `(error, files)`, where `files` is an array containing the names of each file in the directory, excluding `.` and `..`.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}